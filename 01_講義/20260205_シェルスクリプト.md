# 1. `変数`
データを格納しておくための入れ物。
</br>
</br>


## 変数へ値を代入
変数にデータを格納することを「代入」という。
```bash
SAKANA=Saba
# "="の両側にはスペースを入れてはいけない
# 変数名は大文字で作成する(業界の暗黙のルールがある)
```
</br>


## 変数の参照
変数に格納されている値を参照する。
```bash
echo $SAKANA
Saba
```
</br>


## 変数参照時の注意点
変数名は明示的に指定すること。
```bash
DATE="2026_02_05"
echo $DATE
2026_02_05

echo $DATE_Thu
# 何も表示されない
# bashが変数名を「DATE_Thu」と認識してしまったため。

echo ${DATE}_Thu
2026_02_05_Thu
```
</br>


## 変数名の付け方
あとでどのような変数名にしたかわからなくならないように、その内容がわかるような名前をつけましょう。
```bash
# 使用中の変数一覧を確認する
set
-------------------------
BASH=/bin/bash
BASH_ENV=/root/.bashrc
DIRSTACK=()
〜省略〜
-------------------------
```
</br>


## 環境変数
- ### 変数
    - #### シェル変数　→　実行したシェル内のみで実行可能
    - #### 環境変数　→　システム動作に影響する変数。

```bash
# シェル変数を設定する
SAKANA=Saba

# 環境変数を設定する
export SAKANA
```

- ### メタ文字
    - #### メタ文字　→　シェルにとって意味を持った文字。
    - #### リテラル文字　→　文字列そのもの。

</br>
</br>

- ### 代表的なメタ文字
| メタ文字 | 名称 / 種類 | 簡単な説明 | 使用例 |
|--------|-------------|------------|--------|
| > | 出力リダイレクト | 標準出力をファイルに上書き出力 | ls > list.txt |
| >> | 追記リダイレクト | 標準出力をファイルに追記 | echo "a" >> a.txt |
| < | 入力リダイレクト | ファイル内容を標準入力として読み込む | sort < a.txt |
| \| | パイプ | 左の出力を右の入力へ渡す | ls \| grep txt |
| * | ワイルドカード | 任意の文字列に一致 | *.txt |
| ? | ワイルドカード | 任意の1文字に一致 | file?.txt |
| [] | ワイルドカード | 指定文字のいずれか1文字に一致 | file[1-3].txt |
| ; | コマンド区切り | コマンドを順番に連続実行 | cd /; ls |
| && | AND実行 | 左が成功した場合のみ右を実行 | mkdir a && cd a |
| \|\| | OR実行 | 左が失敗した場合のみ右を実行 | cd a \|\| mkdir a |
| & | バックグラウンド | コマンドをバックグラウンド実行 | sleep 10 & |
| $ | 変数展開 | 変数の値を展開する | echo $HOME |
| $( ) | コマンド置換 | コマンド結果を埋め込む | echo $(date) |
| ` ` | コマンド置換 | コマンド結果を埋め込む（旧式） | echo `date` |
| {} | ブレース展開 | 連番や範囲の展開 | file{1..5}.txt |
| ' ' | シングルクォート | 文字をそのまま扱う（展開しない） | echo '$HOME' |
| " " | ダブルクォート | 変数展開はするが空白を保持 | echo "$HOME" |
| \ | エスケープ | 次の1文字の特別な意味を無効化 | echo \$HOME |
| # | コメント | 行末までコメント扱い | # コメント |


</br>
</br>



## バッククォートの使用例
バッククォートでコマンドラインをも維持列を括るとそのコマンドを実行した際の出力に置き換わる。
```bash
# 使用例
echo 今日の日付は`date +%Y_%m_%d`
今日の日付は2026_02_05

# バックアップコマンド例
cp -a file file-`date +%Y_%m_%d`.bak
ls
file  file-2026_02_05.bak
```
</br>
</br>



## メタ文字を普通の文字として扱う
```bash
# ファイルを作成する。
touch "SABA MISO"
ls -l
'SABA MISO'


```
</br>
</br>




## 正規表現
文字列のパターンを表現する記法。

| 演算子 | 名称 / 種類 | 簡単な説明 | 使用例 | マッチ例 |
|--------|------------|------------|--------|----------|
| . | 任意の1文字 | 改行以外の任意の1文字に一致 | a.c | abc, a9c |
| * | 0回以上の繰り返し | 直前の文字が0回以上繰り返し | ab*c | ac, abc, abbc |
| + | 1回以上の繰り返し | 直前の文字が1回以上繰り返し | ab+c | abc, abbc |
| ? | 0回 or 1回 | 直前の文字が0回または1回 | colou?r | color, colour |
| {n} | 回数指定 | 直前の文字がn回 | a{3} | aaa |
| {n,} | n回以上 | 直前の文字がn回以上 | a{2,} | aa, aaa |
| {n,m} | 範囲指定 | 直前の文字がn〜m回 | a{2,4} | aa, aaa |
| [] | 文字クラス | 指定したいずれか1文字 | [abc] | a, b |
| [^] | 否定文字クラス | 指定以外の1文字 | [^abc] | d, e |
| \| | OR（選択） | いずれかに一致 | cat\|dog | cat, dog |
| ^ | 行頭アンカー | 行の先頭に一致 | ^abc | abc123 |
| $ | 行末アンカー | 行の末尾に一致 | abc$ | 123abc |
| () | グループ化 | パターンをまとめる | (ab)+ | ab, abab |
| \\ | エスケープ | 特殊文字を通常文字に | \\. | . |
| \d | 数字 | 0〜9の数字1文字 | \d\d | 12 |
| \w | 単語文字 | 英数字とアンダースコア | \w+ | abc_1 |
| \s | 空白文字 | スペース・タブ・改行 | a\sb | a b |

</br>
</br>
</br>
</br>




# 2. `シェルスクリプト`
通常はBashを使用する。
最近のMacは、ZShellがデフォルトになっている。

## バッチ処理
システムがコマンドを自動実行する処理。


```bash
# シェルの作成
vi hello.sh
-------------------------
#!/bin/sh
echo "Hello world" 
-------------------------

# 実行
sh hello.sh

# 実行権限をつけて実行
chmod u+x hello.sh
./hello.sh

# 実行権限を付与すると、「#!/bin/sh」が意味を持つようになる。
# Linux側でこのファイルは、shで実行するという意味を持つようになる。
```
</br>
</br>


## シェルを対話形式で作成する
```bash
# ファイル作成
vi read.sh
-------------------------
#!/bin/sh
echo "キーを入力してください"
read INPUTKEY
echo "あなたは ${INPUTKEY} と入力しました。"
-------------------------

# シェル実行
sh read.sh
```
</br>
</br>



## スクリプトの引数扱い
```bash
# シェル作成
vi starter.sh
-------------------------
#!/bin/sh
echo "先発投手予想"
echo "１日目は $1"
echo "２日目は $2"
echo "３日目は $3"
-------------------------

# シェル実行
sh starter.sh Igawa Irabu Moore
-------------------------
先発投手予想
１日目は Igawa
２日目は Irabu
３日目は Moore
-------------------------
```
</br>
</br>



# 3. `条件分岐`
条件が正しいときは、真
<br>
条件が正しくないときは、偽


## if 〜 then 〜 if
```bash
# シェル作成
vi holiday_info.sh
-------------------------
#!/bin/sh
if [ `date +%w` = 5 ]
then
    echo "明日はお休みです"
fi
-------------------------

# シェル実行
sh holiday_info.sh
-------------------------
明日はお休みです
-------------------------
```

## if 〜 then 〜 else 〜 if
条件に当てはまらなかった処理を記述するときに使用する。
```bash
# シェル作成
vi holiday_info2.sh
-------------------------
#!/bin/sh
if [ `date +%w` = 4 ]; then
    echo "今日は金曜日です"
else
    echo "今日は金曜日ではありません"
fi
-------------------------
```

## if 〜 then 〜 elif 〜 else 〜 if
条件に当てはまらなかった処理を記述するときに使用する。
```bash
# シェル作成
vi holiday_info3.sh
-------------------------
#!/bin/sh
if [ `date +%w` = 5 ]
then
    echo "今日は金曜日です"
elif [ `date +%w` = 6 ] || [ `date +%w` = 7 ]
then
    echo "今日は休日です。ゆっくり休みましょう。"
else
    echo "今日は金曜日ではありません"
fi
-------------------------
```


## 変数に値がない場合の注意点
```bash
if [ $NAME = "さばみそ" ]
# 上記の場合、変数に値がないNULLエラーになる可能性がある。
# エラーを避けるため、空文字をいれるようにする。
# 以下のように記述する。

NAME = ""
if [ "$NAME" = "さばみそ" ]
then
    echo "美味しいです"
fi

# 上記にすることで以下となり、構文エラーを回避することができる
if [ "" = "さばみそ" ]
```




## &&
左のコマンドAが終了ステータス0を返したときだけ右側のコマンドBを実行する。
```bash
コマンドA && コマンドB

# ソフトウェアのコンパイルとインストールを行う
./configure && make && make install
```

## ||
左のコマンドAが終了ステータス0以外を返した場合に右側のコマンドBを実行する。
```bash
コマンドA || コマンドB

# 例:ディレクトリ"/dir"が存在しない場合にディレクトリを作成する。
[ -d /dir ] || mkdir /dir
```




# 演習
```bash
vi check_10.sh
-------------------------
#!/bin/sh
if [ 10 = $1 ]
then
    echo "当たり！"
fi
-------------------------

sh check_10.sh 10
```
```bash
vi check_empty.sh 
-------------------------
#!/bin/sh
echo "キーを入力してください"
read INPUTKEY

if [ "$INPUTKEY" = "" ]
then
    echo "何も入力されていません"
fi
-------------------------

sh check_empty.sh
```
```bash
vi check_hello.sh
-------------------------
#!/bin/sh
if [  "hello" = "$1" ]
then
    echo "world"
fi
-------------------------

sh check_hello.sh "hello"
```
```bash
vi check_yes.sh
-------------------------
#!/bin/sh
echo "yesかnoを入力してください"
read INPUTKEY

if [  "$INPUTKEY" = "yes" ]
then
    echo "実行します"
fi
-------------------------

sh check_yes.sh
```
```bash
vi check_gt100.sh
-------------------------
#!/bin/sh

if [  $1 -gt 100 ]
then
    echo "100を超えています"
fi
-------------------------

sh check_gt100.sh 120
```
```bash
vi check_file.sh
-------------------------
#!/bin/sh

if [  -f $1 ]
then
    echo "$1は存在します"
fi
-------------------------

sh check_file.sh check_gt100.sh
```
```bash
vi check_dir.sh
-------------------------
#!/bin/sh

if [  -d $1 ]
then
    echo "$1は存在します"
fi
-------------------------

sh check_dir.sh /home
```
```bash
vi check_sunday.sh
-------------------------
#!/bin/sh

if [  `date +%w` = 0 ]
then
    echo "今日は日曜日です"
fi
-------------------------

sh check_sunday.sh
```
```bash
vi check_no_args.sh
-------------------------
#!/bin/sh

if [  $# = 0 ]
then
    echo "引数が必要です"
fi
-------------------------

sh check_no_args.sh
```
```bash
vi check_not_empty.sh
-------------------------
#!/bin/sh

echo "入力してください"
read INPUTKEY

if [ "$INPUTKEY" != "" ]
then
    echo "入力されました"
fi
-------------------------

sh check_not_empty.sh
```

</br>
</br>
</br>


### case文
```bash
vi confirm_case.sh
-------------------------
#!/bin/sh

echo "yes / no / cancel"
read INPUTKEY

case $INPUTKEY in
    "yes")
        echo "はい"
    ;;
    "no")
        echo "いいえ"
    ;;
    "cancel")
        echo "キャンセル"
    ;;
    *)
        echo "yes/no/cancelで入力してください"
esac
-------------------------

sh confirm_case.sh
```


### for文
testという変数を使ってfor処理をする</br>
値の数だけ繰り返す
```bash
vi for_test.sh
-------------------------
#!/bin/sh

for test in test1 test2 test3
do
    touch "$test.txt"
done
-------------------------

sh for_test.sh
```


```bash
vi count_5.sh
-------------------------
#!/bin/sh

for (( i=1; i<=5; i++ ))
do
  echo "$i"
done
echo "処理が終わりました。"
-------------------------

sh count_5.sh
```



### while文
終了ステータスが「0」になるまでループし続ける。
終了ステータスが「0以外」になるとループから抜ける。
```bash
vi while.sh
-------------------------
#!/bin/sh

for rm test.txt
do
  echo "削除完了"
done
-------------------------

sh while.sh
```



